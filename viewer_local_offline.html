<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Scene Viewer (Local offline)</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#0f1115}
    #info{position:fixed;top:8px;left:8px;color:#fff;font:12px/1.4 sans-serif;opacity:.9;z-index:10;max-width:90vw}
    #info code{background:#222;padding:2px 4px;border-radius:4px}
    #status{margin-top:6px}
  </style>
</head>
<body>
<div id="info">
  WS: <code id="wsurl"></code>
  <div id="status">booting…</div>
  <div>Test POST:</div>
  <code>curl -X POST http://localhost:8080/api/scene/push -H "X-Scene-Token: changeme" -H "Content-Type: application/json" -d '{"frame":"map","objects":[{"id":1,"class":"box","mesh_uri":"builtin:box","position_m":[0,0,0],"orientation_xyzw":[0,0,0,1],"scale":[1,1,1]}]}'</code>
</div>
<canvas id="c"></canvas>

<script type="module">
// ---------- Endpoint autodetect (same-host preferred) ----------
const host = (location.hostname && location.hostname !== 'localhost') ? location.hostname : 'localhost';
const WS_URL      = `ws://${host}:8080/ws/scene`;
const API_LATEST  = `http://${host}:8080/api/scene/latest`;
document.getElementById('wsurl').textContent = WS_URL;

// (NEW) assets base — 너의 GLB가 ~/scenehub/assets/furniture 에 있으므로:
const ASSET_BASE  = `http://${host}:8000/assets/furniture`;

const statusEl = document.getElementById('status');
function setStatus(t){ statusEl.textContent = t; console.log('[viewer]', t); }

// ---------- Local three.js modules ----------
import * as THREE from './lib/three/three.module.js';
import { OrbitControls } from './lib/three/OrbitControls.js';
import { GLTFLoader }   from './lib/three/GLTFLoader.js';

setStatus('modules loaded');

// ---------- Class → GLB map (viewer-side fallback) ----------
const CLASS_TO_GLTF = {
  'chair':         `${ASSET_BASE}/chair.glb`,
  'table':         `${ASSET_BASE}/table.glb`,
  'dining table':  `${ASSET_BASE}/officeTable.glb`,
  'round table':   `${ASSET_BASE}/roundtable.glb`,
  'student chair': `${ASSET_BASE}/studentChair.glb`,
  'desk':          `${ASSET_BASE}/officeTable.glb`,
  'couch':         `${ASSET_BASE}/roundtable.glb`,
};
// YOLO 라벨 변형 보정
const ALIASES = { 'dining_table':'dining table', 'round_table':'round table', 'sofa':'couch' };
for (const [a, base] of Object.entries(ALIASES)) {
  if (!CLASS_TO_GLTF[a] && CLASS_TO_GLTF[base]) CLASS_TO_GLTF[a] = CLASS_TO_GLTF[base];
}
const norm = s => String(s||'').trim().toLowerCase();

// ---------- Three.js setup ----------
const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0f1115);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.01, 2000);
camera.position.set(3,3,3);

const controls = new OrbitControls(camera, renderer.domElement);
controls.target.set(0,0,0); controls.update();

scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dl = new THREE.DirectionalLight(0xffffff, 1); dl.position.set(3,5,2); scene.add(dl);
scene.add(new THREE.GridHelper(20,20));

function resize(){ renderer.setSize(innerWidth, innerHeight); camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); }
addEventListener('resize', resize);
resize();
(function loop(){ renderer.render(scene, camera); requestAnimationFrame(loop); })();

// ---------- Asset loading ----------
const loader = new GLTFLoader();
const glbCache = new Map();

async function getGLB(uri){
  // support relative (/assets/...) and absolute (http://IP:8000/...) URIs
  const key = uri;
  if(!glbCache.has(key)){
    const gltf = await loader.loadAsync(uri);
    glbCache.set(key, gltf.scene);
  }
  return glbCache.get(key).clone(true);
}

function builtinMesh(kind){
  switch(kind){
    case 'box':      return new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial());
    case 'sphere':   return new THREE.Mesh(new THREE.SphereGeometry(0.5,32,16), new THREE.MeshStandardMaterial());
    case 'cylinder': return new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.4,1,24), new THREE.MeshStandardMaterial());
    default:         return new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial());
  }
}

// ---------- Live object map (upsert-only) ----------
const live = new Map();

/**
 * Upsert-only diff:
 * - create/update objects listed in diff.objects
 * - remove only if the object has { delete:true } or { deleted:true }
 * No global "remove unseen" sweep (prevents flicker on partial updates)
 */
async function applyDiff(diff){
  if(!diff || !Array.isArray(diff.objects)) return;

  for(const o of diff.objects){
    // explicit deletion
    if (o.delete === true || o.deleted === true){
      const obj = live.get(o.id);
      if (obj){ scene.remove(obj); live.delete(o.id); }
      continue;
    }

    // --- mesh_uri rewrite (핵심) ---
    let uri = o.mesh_uri || '';

    // package://...dae → /assets/*.glb 로 리라이트
    if (uri.startsWith('package://')) {
      const fname = uri.split('/').pop().replace(/\.dae$/i, '.glb');
      uri = `${ASSET_BASE}/${fname}`;
    }
    // builtin/empty → class 기반으로 보충
    if ((!uri || uri.startsWith('builtin:')) && o.class) {
      const key = norm(o.class);
      if (CLASS_TO_GLTF[key]) uri = CLASS_TO_GLTF[key];
    }
    console.log('[viewer] resolved uri for id', o.id, 'class=', o.class, '=>', uri);

    // create if missing
    let obj = live.get(o.id);
    if(!obj){
      if(String(uri||'').startsWith('builtin:')){
        obj = builtinMesh(String(uri).split(':')[1]||'box');
      }else if(uri){
        try{
          obj = await getGLB(uri);
        }catch(e){
          console.error('[viewer] GLB load failed for', uri, e);
          // fallback to box so we don't lose the instance
          obj = builtinMesh('box');
        }
      }else{
        obj = builtinMesh('box');
      }
      scene.add(obj);
      live.set(o.id, obj);
    }

    // apply transforms (with sane guards)
    if(Array.isArray(o.position_m)){
      obj.position.set(o.position_m[0]||0, o.position_m[1]||0, o.position_m[2]||0);
    }
    if(Array.isArray(o.orientation_xyzw) && o.orientation_xyzw.length===4){
      obj.quaternion.set(
        Number(o.orientation_xyzw[0])||0,
        Number(o.orientation_xyzw[1])||0,
        Number(o.orientation_xyzw[2])||0,
        Number(o.orientation_xyzw[3])||1
      );
    }
    if(Array.isArray(o.scale)){
      obj.scale.set(
        Math.max(5e-2, Number(o.scale[0])||1),
        Math.max(5e-2, Number(o.scale[1])||1),
        Math.max(5e-2, Number(o.scale[2])||1)
      );
    }
  }
}

// ---------- Initial snapshot ----------
try{
  const r = await fetch(API_LATEST, {cache:'no-store'});
  if(r.ok){
    await applyDiff(await r.json());
    setStatus('loaded latest snapshot');
  }else{
    setStatus('failed to load latest snapshot: '+r.status);
  }
}catch(e){
  console.warn('[viewer] latest fetch failed', e);
}

// ---------- WebSocket live updates ----------
setStatus('connecting ws…');
const ws = new WebSocket(WS_URL);
ws.onopen  = ()=> setStatus('WebSocket connected');
ws.onerror = e => { console.error('[viewer] ws error', e); setStatus('WebSocket error'); };
ws.onclose = ()=> setStatus('WebSocket closed');
ws.onmessage = async ev => {
  try{
    const diff = JSON.parse(ev.data);
    if(diff.frame === 'map') await applyDiff(diff);
  }catch(e){ console.error('[viewer] onmessage parse/apply error', e); }
};
</script>
</body>
</html>
