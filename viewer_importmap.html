<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Scene Viewer (importmap)</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#0f1115}
    #info{position:fixed;top:8px;left:8px;color:#fff;font:12px/1.4 sans-serif;opacity:.95;z-index:10;max-width:92vw}
    #info code{background:#222;padding:2px 4px;border-radius:4px}
    #status{margin-top:6px;white-space:pre-wrap}
  </style>

  <!-- ★ import map: 'three' 패키지 경로를 로컬 파일로 매핑 -->
  <script type="importmap">
  {
    "imports": {
      "three": "./lib/three/three.module.js",
      "three/examples/jsm/": "./lib/three/"
    }
  }
  </script>
</head>
<body>
<div id="info">
  WS: <code id="wsurl"></code>
  <div id="status">booting…</div>
  <div>Test POST:</div>
  <code>curl -X POST http://localhost:8080/api/scene/push -H "X-Scene-Token: changeme" -H "Content-Type: application/json" -d '{"frame":"map","objects":[{"id":1,"class":"box","mesh_uri":"builtin:box","position_m":[0,0,0],"orientation_xyzw":[0,0,0,1],"scale":[1,1,1]}]}'</code>
</div>
<canvas id="c"></canvas>

<script type="module">
const WS_URL = 'ws://localhost:8080/ws/scene';
const API_LATEST = 'http://localhost:8080/api/scene/latest';
document.getElementById('wsurl').textContent = WS_URL;

const statusEl = document.getElementById('status');
const setStatus = (t)=>{ statusEl.textContent = t; console.log('[viewer]', t); };

try {
  setStatus('loading modules via importmap…');
  // ★ 이제 패키지 이름으로 임포트 가능
  import * as THREE from 'three';
  const { OrbitControls } = await import('three/examples/jsm/controls/OrbitControls.js');
  const { GLTFLoader }  = await import('three/examples/jsm/loaders/GLTFLoader.js');
  setStatus('modules loaded');

  // ----- scene setup -----
  const canvas = document.getElementById('c');
  const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
  function resize(){ renderer.setSize(innerWidth, innerHeight); camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); }
  addEventListener('resize', resize);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0f1115);

  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.01, 2000);
  camera.position.set(3,3,3);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.target.set(0,0,0); controls.update();

  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const dl = new THREE.DirectionalLight(0xffffff, 1); dl.position.set(3,5,2); scene.add(dl);
  scene.add(new THREE.GridHelper(20,20));

  const loader = new GLTFLoader();
  const cache = new Map();
  async function getGLB(uri){
    if(!cache.has(uri)){
      const gltf = await loader.loadAsync(uri);
      cache.set(uri, gltf.scene);
    }
    return cache.get(uri).clone(true);
  }
  function builtinMesh(kind){
    switch(kind){
      case 'box': return new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial());
      case 'sphere': return new THREE.Mesh(new THREE.SphereGeometry(0.5,32,16), new THREE.MeshStandardMaterial());
      case 'cylinder': return new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.4,1,24), new THREE.MeshStandardMaterial());
      default: return new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial());
    }
  }

  const live = new Map();
  async function applyDiff(diff){
    if(!diff || !Array.isArray(diff.objects)) return;
    const seen = new Set();
    for(const o of diff.objects){
      seen.add(o.id);
      let obj = live.get(o.id);
      if(!obj){
        obj = String(o.mesh_uri||'').startsWith('builtin:')
          ? builtinMesh(String(o.mesh_uri).split(':')[1]||'box')
          : await getGLB(o.mesh_uri);
        scene.add(obj); live.set(o.id,obj);
      }
      if(Array.isArray(o.position_m)) obj.position.set(o.position_m[0]||0, o.position_m[1]||0, o.position_m[2]||0);
      if(Array.isArray(o.orientation_xyzw) && o.orientation_xyzw.length===4) obj.quaternion.set(
        o.orientation_xyzw[0], o.orientation_xyzw[1], o.orientation_xyzw[2], o.orientation_xyzw[3]
      );
      if(Array.isArray(o.scale)) obj.scale.set(
        Math.max(1e-3,o.scale[0]||1), Math.max(1e-3,o.scale[1]||1), Math.max(1e-3,o.scale[2]||1)
      );
    }
    for(const [id,obj] of Array.from(live.entries())) if(!seen.has(id)){ scene.remove(obj); live.delete(id); }
  }

  function loop(){ renderer.render(scene, camera); requestAnimationFrame(loop); }
  resize(); loop();

  // latest snapshot once
  try{
    const r = await fetch(API_LATEST);
    if(r.ok){ await applyDiff(await r.json()); setStatus('loaded latest snapshot'); }
    else setStatus('failed to load latest snapshot: '+r.status);
  }catch(e){ console.warn('latest fetch failed', e); }

  // ws
  setStatus('connecting ws…');
  const ws = new WebSocket(WS_URL);
  ws.onopen = ()=> setStatus('WebSocket connected');
  ws.onerror = ()=> setStatus('WebSocket error');
  ws.onclose = ()=> setStatus('WebSocket closed');
  ws.onmessage = async ev => {
    try{ const diff = JSON.parse(ev.data); if(diff.frame==='map') await applyDiff(diff); }
    catch(e){ console.error('onmessage parse/apply error', e); }
  };
} catch(err){
  setStatus('FATAL: '+err.message+' (자세한 내용은 F12 Console)');
}
</script>
</body>
</html>
